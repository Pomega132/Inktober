@page "/2025/4"

@inject IJSRuntime JS
@implements IAsyncDisposable

<h3>04 - Trouble</h3>

<MudPaper Class="d-flex justify-space-around">
	<video id="video" class="border" style="width:45vw; height:auto;" onload="LoadCam()"></video>

	<canvas id="effect" width="640" height="480" style="width:45vw; height:auto;"></canvas>
</MudPaper>

<script>
	window.LoadCam = function () {
		// Demander l'acces √† la cam√©ra.
		navigator.mediaDevices.getUserMedia({ video: true })
			.then(async function (stream) {
				// Afficher le flux vid√©o dans l'√©l√©ment video.
				var video = document.getElementById('video');
				video.srcObject = stream;
				video.play();

				video.addEventListener('playing', function() {
					StartCapturing(video);
					animationLoop();
				});
			})
			.catch(function (err) {
				console.log("Une erreur s'est produite: " + err);
			});
	}

	window.DisposeCam = function(){
		var video = document.getElementById('video');
		var stream = video.srcObject;
		var tracks = stream.getTracks();
		tracks.forEach(function(track) {
			track.stop();
		});
		video.srcObject = null;
	}

	var buffer = [];
	var BUFFER_SIZE = 25;

	function AddToBuffer(image){
		buffer.unshift(image);

		while(buffer.length > BUFFER_SIZE) {
			buffer.pop();
		}
	}

	  async function UpdateEffect(){
		const canvas = document.getElementById('effect');
		const ctx = canvas.getContext('2d');

		// Si les dimensions vid√©o changent, tu peux adapter :
		// canvas.width = buffer[0]?.width ?? canvas.width;
		// canvas.height = buffer[0]?.height ?? canvas.height;

		ctx.clearRect(0, 0, canvas.width, canvas.height);

		// Snapshot pour √©viter que le buffer soit modifi√© pendant le dessin
		const frames = buffer.slice();
		for (let i = 0; i < frames.length; i++) {
			const frame = frames[i];
			const alpha = 1 - (i / BUFFER_SIZE);
			ctx.globalAlpha = alpha;
			ctx.drawImage(frame, 0, 0, canvas.width, canvas.height);
		}
		ctx.globalAlpha = 1;
	}

	async function StartCapturing(video) {
		// Canvas de capture (hors-DOM)
		const grab = document.createElement('canvas');
		const gctx = grab.getContext('2d');
		grab.width = video.videoWidth;
		grab.height = video.videoHeight;

		async function captureFrame() {
			gctx.drawImage(video, 0, 0, grab.width, grab.height);
			// üëâ Pas de dataURL : on fabrique directement un ImageBitmap (tr√®s rapide)
			const bitmap = await createImageBitmap(grab);
			AddToBuffer(bitmap);

			// Capture toutes les 200 ms (5 images/s)
			setTimeout(captureFrame, 20);
		}

		captureFrame();
	}

	function animationLoop() {
		UpdateEffect().catch(console.error);
		requestAnimationFrame(animationLoop);
	}
</script>

@code {
	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
			// Appeler la fonction JavaScript pour charger la cam√©ra.
			await JS.InvokeVoidAsync("LoadCam");
		}
		await base.OnAfterRenderAsync(firstRender);
	}

	public async ValueTask DisposeAsync()
	{
		await JS.InvokeVoidAsync("DisposeCam");
	}
}
